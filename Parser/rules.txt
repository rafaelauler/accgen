//===- rules.txt   Transformation rules definition file   -----------------===//
//
//              The ArchC Project - Compiler Backend Generation
//
//===----------------------------------------------------------------------===//
//
// BLABLA
//
//===----------------------------------------------------------------------===//

//==========================-- Operators --===================================//

// Built-in operators: +, -, ~, transfer, call, ret, memref
// These operands must exist
define operator +        as arity 2;
define operator -        as arity 2;
define operator ~        as arity 1;
define operator xor      as arity 2;
define operator transfer as arity 2;
define operator if       as arity 3;
define operator equal    as arity 2;
define operator dec      as arity 2;
define operator shl      as arity 2;            // Shift left
define operator shr      as arity 2;            // Shift right
define operator asr      as arity 2;            // Arithmetic shift right
define operator and      as arity 2;
define operator or       as arity 2;
//NOTE: MemRef is a special case not affected by wildcard rules
define operator memref   as arity 1;
define operator call     as arity 1;
define operator ret      as arity 0;
define operator jump     as arity 1;
// CJUMP is a special conditional jump node and is not straightforward
// The first operand has the conditional code, the second is the
// comparator operator and the third, the target
define operator cjump    as arity 3;
define operator comp     as arity 2;
define operator alias    as add => +;
define operator alias    as sub => -;


//===========================-- Operands --===================================//

// Built-in operands: int, tgtimm
// These operands must exist
define operand int    as size 32;
define operand mem    as size 32;
define operand cond   as size 32;
define operand tgtimm as size 32 like int;
define operand regs   as size 32 like int;
define operand short  as size 16 like int;
define operand byte   as size 8  like int;
define operand nibble as size 4  like int;
define operand bit    as size 1  like int;

//============================-- Rules --=====================================//

AnyOperator:any => (dec (transfer AReg:regs^ AnyOperator:any) AReg:regs^);

AnyOperator:any <=> (+ const:int:0 AnyOperator:any);

(transfer (memref AnyOperator1:any) (memref AnyOperator2:any)) => 
  (dec (transfer AReg:regs (memref AnyOperator2:any)) (transfer (memref AnyOperator1:any) AReg:regs));

const:int:0 => (xor Reg:regs Reg:regs);

// split large immediate rule
imm:oper:int => (dec (transfer AReg:regs (+ (shl imm:op1:short const:byte:16) imm:op2:short)) AReg:regs)
( oper binds to op1 using "oper >> 16";
  oper binds to op2 using "oper & 0xFFFF";
);
imm:oper:short => (dec (transfer AReg:regs (+ (shl imm:op1:byte const:byte:8) imm:op2:byte)) AReg:regs)
( oper binds to op1 using "oper >> 8";
  oper binds to op2 using "oper & 0xFF";
);

//=========================-- LLVM Patterns --================================//

// It is important to order similar patterns, most restrictive first.

//define pattern STOREADDFICONST as (
//  "(store (imm i32:$src), (add i32:$a1 (frameindex i32:$val)))";
//  (transfer (memref (+ a1:regs (+ val:regs imm:val:immed))) imm:src:immed);
//);

define pattern STOREFICONST as (
  "(store (imm i32:$src), (frameindex i32:$val))";
  (transfer (memref (+ val:regs imm:val:tgtimm)) imm:src:tgtimm);
);

define pattern STOREFROMFI as (
  "(store (frameindex i32:$valsrc) i32:$addr)";
  (transfer (memref addr:regs) 
    (memref (+ valsrc:regs imm:valsrc:tgtimm)));
);

// Built-in pattern: STOREFI is used to determine how the backend will spill
// registers to stack frame. This pattern must exist, with the correct
// operand names (src and val).
define pattern STOREFI as (
  "(store i32:$src, (frameindex i32:$val))";
  (transfer (memref (+ val:regs imm:val:tgtimm)) src:regs);
);

// Built-in pattern: STOREADDCONST is used to help emit prologue
define pattern STOREADDCONST as (
  "(store i32:$src, (add i32:$a1, (imm i32:$a2)))";
  (transfer (memref (+ a1:regs imm:a2:tgtimm)) src:regs);
);

// Built-in pattern: STOREADD is used to help handle large frameindexes
define pattern STOREADD as (
  "(store i32:$src, (add i32:$reg1, i32:$reg2))";
  (transfer (memref (+ reg1:regs reg2:regs)) src:regs);
);

define pattern STORE as (
  "(store i32:$src, i32:$addr)";
  (transfer (memref addr:regs) src:regs);
);

// Built-in pattern: LOADFI is used to determine how the backend will load
// spilled registers from stack frame. This pattern must exist, with the
// correct operand names (addr and dest).
define pattern LOADFI as (
  "(load (frameindex i32:$addr))";
  (transfer dest:regs (memref (+ addr:regs imm:addr:tgtimm)));
);

// Built-in pattern: LOADADDCONST is used to help emit epilogue
define pattern LOADADDCONST as (
  "(load (add i32:$a1, (imm i32:$a2)))";
  (transfer dest:regs (memref (+ a1:regs imm:a2:tgtimm)));
);

// Built-in pattern: LOADADD is used to help handle large frameindexes
define pattern LOADADD as (
  "(load (add i32:$reg1, i32:$reg2))";
  (transfer dest:regs (memref (+ reg1:regs reg2:regs)));
);

define pattern LOAD as (
  "(load i32:$addr)";
  (transfer a3:regs (memref addr:regs));
);

define pattern GLOBALADDRESS as (
  "(globaladdr i32:$addr)";
  (transfer a3:regs (memref (+ addr:regs imm:addr:short)));
);

// Built-int pattern: FRAMEINDEX is used to identify frameindexes
// accesses and adjust the immediates
define pattern FRAMEINDEX as (
  "(frameindex i32:$addr)";
  (transfer a3:regs (+ addr:regs imm:addr:tgtimm));
);

define pattern CALL as (
  "(call (tglobaladdr i32:$tgt))";
  (call imm:tgt:int);
);

define pattern CALL2 as (
  "(call (texternalsymbol i32:$tgt))";
  (call imm:tgt:int);
);

// Built-in pattern: ADDCONST is used to adjust stack when target-immediate
// size values are used.
define pattern ADDCONST as (
  "(add i32:$a1, (imm i32:$a2))";
  (transfer a3:regs (+ a1:regs imm:a2:tgtimm));
);

// Built-in pattern: ADD is used to adjust stack when large immediates
// are loaded into one register
define pattern ADD as (
  "(add i32:$a1, i32:$a2)";
  (transfer a3:regs (+ a1:regs a2:regs));
);

// Built-in pattern: SUBCONST is used to adjust stack when target-immediate
// size values are used.
define pattern SUBCONST as (
  "(sub i32:$a1, (tgtimm i32:$a2))";
  (transfer a3:regs (- a1:regs imm:a2:tgtimm));
);

// Built-in pattern: SUB is used to adjust stack when large immediates
// are loaded into one register
define pattern SUB as (
  "(sub i32:$a1, i32:$a2)";
  (transfer a3:regs (- a1:regs a2:regs));
);

define pattern SHLCONST as (
  "(shl i32:$a1, (tgtimm i32:$a2))";
  (transfer a3:regs (shl a1:regs imm:a2:tgtimm));
);

define pattern SHRCONST as (
  "(srl i32:$a1, (tgtimm i32:$a2))";
  (transfer a3:regs (shr a1:regs imm:a2:tgtimm));
);

define pattern SRACONST as (
  "(sra i32:$a1, (tgtimm i32:$a2))";
  (transfer a3:regs (asr a1:regs imm:a2:tgtimm));
);

define pattern OR as (
  "(or i32:$a1, i32:$a2)";
  (transfer a3:regs (or a1:regs a2:regs));
);

define pattern BRCOND as (
  "(br_cc (condcode SETLT) i32:$lhs i32:$rhs (basicblock i32:$tgt))";
  (cjump const:cond:lt (comp lhs:regs rhs:regs) imm:tgt:int);
);

define pattern BRCOND2 as (
  "(br_cc (condcode SETGT) i32:$lhs i32:$rhs (basicblock i32:$tgt))";
  (cjump const:cond:gt (comp lhs:regs rhs:regs) imm:tgt:int);
);

define pattern BRCOND3 as (
  "(br_cc (condcode SETULT) i32:$lhs i32:$rhs (basicblock i32:$tgt))";
  (cjump const:cond:ult (comp lhs:regs rhs:regs) imm:tgt:int);
);

define pattern BRCOND4 as (
  "(br_cc (condcode SETUGT) i32:$lhs i32:$rhs (basicblock i32:$tgt))";
  (cjump const:cond:ugt (comp lhs:regs rhs:regs) imm:tgt:int);
);

define pattern BRCOND5 as (
  "(br_cc (condcode SETNE) i32:$lhs i32:$rhs (basicblock i32:$tgt))";
  (cjump const:cond:ne (comp lhs:regs rhs:regs) imm:tgt:int);
);

define pattern BRCOND6 as (
  "(br_cc (condcode SETEQ) i32:$lhs i32:$rhs (basicblock i32:$tgt))";
  (cjump const:cond:eq (comp lhs:regs rhs:regs) imm:tgt:int);
);

define pattern BR as (
  "(br (basicblock i32:$tgt))";
  (jump imm:tgt:int);
);

define pattern CONST as (
  "(tgtimm i32:$a1)";
  (transfer a2:regs imm:a1:tgtimm);
);

// Built-in pattern: CONST16 is used to load a 16-bit immediate when ordinary
// patterns cannot, or when generating code that creates large immediates.
define pattern CONST16 as (
  "(shortimm i32:$a1)";
  (transfer a2:regs imm:a1:short);
);

// Built-in pattern: CONST32 is used to load large immediates (32-bit), similar
// to CONST16, but 32-bit in size.
define pattern CONST32 as (
  "(imm i32:$a1)";
  (transfer a2:regs imm:a1:int);
);

// { lhs < rhs }  SR == LT
// { SR == LT } brancheio 


//====================-- Machine specific rules --============================//

//=====================-- Registers definitions --============================//

// Current Program Status Register

define registers CPSR:regs as ( SR );  // Status register

define registers GPR:regs as (
  r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10 r11 r12 r13 r14 r15
);

//===========================-- ABI stuff --==================================//

redefine operand tgtimm size to 8;

define abi as (
  define callee save registers as (r4 r5 r6 r7);
  define reserved registers as    (r9 r10 r13 r14 r15);
  define auxiliar registers as    (r9 r10);
  //define calling convention for int as stack size 4 alignment 4;
  define calling convention for int as (r0 r1 r2 r3);
  define calling convention for int as stack size 4 alignment 4;
  define return convention for int as (r0 r1);
  define programcounter register as r15;
  define stackpointer register as r13;
  define framepointer register as r11;
  define return register as r14;
  define stack grows down alignment 8;
  define pcoffset -8;
);

//==================-- Instruction semantic fragments --======================//

//====-- Adressing mode fragments -====//

// Simple addressing mode frag
define semantic fragment SimpleAddrMode as (
  Op5:GPR;    
);

// Register shifted by imm 
define semantic fragment RegShiftedAddrMode as (
  (shl Op5:GPR imm:Op7:tgtimm);
);

// Register right shifted by imm 
define semantic fragment RegRightShiftedAddrMode as (
  (shr Op5:GPR imm:Op7:tgtimm);
);

// Register arithmetic right shifted by imm 
define semantic fragment RegARightShiftedAddrMode as (
  (asr Op5:GPR imm:Op7:tgtimm);
);

// Register shifted right by 1 
define semantic fragment RegRotAddrMode as (
  (shr Op5:GPR const:int:1);
);

// Register shifted by an value defined in a register
define semantic fragment RegShifted2AddrMode as (
  (shl Op5:GPR Op7:GPR);
);

// Immediate
define semantic fragment ImmAddrMode as (
  imm:Op5:tgtimm;
);

//=======================-- Instructions definitions --=======================//

// Branch instructions
define instruction b semantic as (
  let Op1 = "" in
    (jump imm:Op2:int);
  let Op1 = "lt" in
    (cjump const:cond:lt SR:CPSR imm:Op2:int);
  let Op1 = "gt" in
    (cjump const:cond:gt SR:CPSR imm:Op2:int);
  let Op1 = "lo" in
    (cjump const:cond:ult SR:CPSR imm:Op2:int);
  let Op1 = "hi" in
    (cjump const:cond:ugt SR:CPSR imm:Op2:int);
  let Op1 = "ne" in
    (cjump const:cond:ne SR:CPSR imm:Op2:int);
  let Op1 = "eq" in
    (cjump const:cond:eq SR:CPSR imm:Op2:int);
) cost 1;
define instruction b semantic as (
  let Op1 = "" in
    (call imm:Op2:int);
) cost 1;

// Data processing instructions

//====-- AND --====//
define instruction and1 semantic as (
  (transfer Op3:GPR (and Op4:GPR SimpleAddrMode:fragment));
) cost 1;
define instruction and1 semantic as (
  (transfer Op3:GPR (and Op4:GPR RegShiftedAddrMode:fragment));
) cost 1;
define instruction and1 semantic as (
  (transfer Op3:GPR (and Op4:GPR RegRotAddrMode:fragment));
) cost 1;
define instruction and2 semantic as (
  (transfer Op3:GPR (and Op4:GPR RegShifted2AddrMode:fragment));
) cost 1;
define instruction and3 semantic as (
  (transfer Op3:GPR (and Op4:GPR ImmAddrMode:fragment));
) cost 1;

//====-- EOR --====//
define instruction eor1 semantic as (
  let Op1 = "", Op2 = "" in
    (transfer Op3:GPR (xor Op4:GPR SimpleAddrMode:fragment));
) cost 1;
define instruction eor1 semantic as (
  (transfer Op3:GPR (xor Op4:GPR RegShiftedAddrMode:fragment));
) cost 1;
define instruction eor1 semantic as (
  (transfer Op3:GPR (xor Op4:GPR RegRotAddrMode:fragment));
) cost 1;
define instruction eor2 semantic as (
  (transfer Op3:GPR (xor Op4:GPR RegShifted2AddrMode:fragment));
) cost 1;
define instruction eor3 semantic as (
  (transfer Op3:GPR (xor Op4:GPR ImmAddrMode:fragment));
) cost 1;

//====-- SUB --====//
define instruction sub1 semantic as (
let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (- Op4:GPR SimpleAddrMode:fragment));
) cost 1;
define instruction sub1 semantic as (
let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (- Op4:GPR RegShiftedAddrMode:fragment));
) cost 1;
define instruction sub1 semantic as (
let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (- Op4:GPR RegRotAddrMode:fragment));
) cost 1;
define instruction sub2 semantic as (
let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (- Op4:GPR RegShifted2AddrMode:fragment));
) cost 1;
define instruction sub3 semantic as (
let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (- Op4:GPR ImmAddrMode:fragment));
) cost 1;

//====-- ADD --====//
define instruction add1 semantic as (
  let Op1 = "", Op2 = "" in
    (transfer Op3:GPR (+ Op4:GPR SimpleAddrMode:fragment));
) cost 1;
define instruction add1 semantic as (
  let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (+ Op4:GPR RegShiftedAddrMode:fragment));
) cost 1;
define instruction add1 semantic as (
  let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (+ Op4:GPR RegRotAddrMode:fragment));
) cost 1;
define instruction add2 semantic as (
  let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (+ Op4:GPR RegShifted2AddrMode:fragment));
) cost 1;
define instruction add3 semantic as (
  let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (+ Op4:GPR ImmAddrMode:fragment));
) cost 1;

//====-- ORR --====//
define instruction orr1 semantic as (
let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (or Op4:GPR SimpleAddrMode:fragment));
) cost 1;
define instruction orr1 semantic as (
let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (or Op4:GPR RegShiftedAddrMode:fragment));
) cost 1;
define instruction orr1 semantic as (
let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (or Op4:GPR RegRotAddrMode:fragment));
) cost 1;
define instruction orr2 semantic as (
let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (or Op4:GPR RegShifted2AddrMode:fragment));
) cost 1;
define instruction orr3 semantic as (
let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (or Op4:GPR ImmAddrMode:fragment));
) cost 1;

//====-- CMP --====//
define instruction cmp1 semantic as (
let Op1 = "" in
  (transfer SR:CPSR (comp Op2:GPR SimpleAddrMode:fragment params (Op3)));
) cost 1;
define instruction cmp1 semantic as (
let Op1 = "" in
  (transfer SR:CPSR (comp Op2:GPR RegShiftedAddrMode:fragment params (Op3 Op4)));
) cost 1;
define instruction cmp1 semantic as (
let Op1 = "" in
  (transfer SR:CPSR (comp Op2:GPR RegRotAddrMode:fragment params (Op3)));
) cost 1;
define instruction cmp2 semantic as (
let Op1 = "" in
  (transfer SR:CPSR (comp Op2:GPR RegShifted2AddrMode:fragment params (Op3 Op4)));
) cost 1;
define instruction cmp3 semantic as (
let Op1 = "" in
  (transfer SR:CPSR (comp Op2:GPR ImmAddrMode:fragment params (Op3)));
) cost 1;

//====-- MOV --====//
define instruction mov1 semantic as (
  let Op1 = "", Op2 = "" in
    (transfer Op3:GPR SimpleAddrMode:fragment params (Op4));
) cost 1;
define instruction mov1 semantic as (
  (ret);
) cost 1;
define instruction mov1 semantic as (
  let Op1 = "", Op2 = "", Op5 = "LSL" in
    (transfer Op3:GPR RegShiftedAddrMode:fragment params (Op4 Op6));
  let Op1 = "", Op2 = "", Op5 = "LSR" in
    (transfer Op3:GPR RegRightShiftedAddrMode:fragment params (Op4 Op6));
  let Op1 = "", Op2 = "", Op5 = "ASR" in
    (transfer Op3:GPR RegARightShiftedAddrMode:fragment params (Op4 Op6));
) cost 1;
define instruction mov1 semantic as (
  let Op1 = "", Op2 = "" in
    (transfer Op3:GPR RegRotAddrMode:fragment params (Op4));
) cost 1;
define instruction mov2 semantic as (
  let Op1 = "", Op2 = "" in
    (transfer Op3:GPR RegShifted2AddrMode:fragment params (Op4 Op6));
//  (transfer Op3:GPR const:int:1);
) cost 1;
define instruction mov3 semantic as (
 let Op1 = "", Op2 = "" in
 //   {SR:CPSR == const:int:1} ->  	
  (transfer Op3:GPR ImmAddrMode:fragment params (Op4));
) cost 1;

//====-- TEQ --====//
//define instruction teq1 semantic as (
  //let Op1 = "" in
    //{Op2:GPR == Op3:GPR} -> (transfer SR:CPSR const:int:1);
  //let Op1 = "" in
//    {Op2:GPR < Op3:GPR} -> (transfer SR:CPSR const:int:10);  
//) cost 1;

//====-- STR --====//
define instruction str1 semantic as (
  let Op1 = "" in
    (transfer (memref Op3:GPR) Op2:GPR);
) cost 1;
define instruction str1 semantic as () cost 1;
define instruction str1 semantic as () cost 1;
define instruction str1 semantic as (
  let Op1 = "" in
    (transfer (memref (add Op3:GPR imm:Op4:tgtimm)) Op2:GPR);
) cost 1;

define instruction str2 semantic as (
  let Op1 = "" in
    (transfer (memref (add Op3:GPR Op4:GPR)) Op2:GPR);
) cost 1;
define instruction str2 semantic as (
  let Op1 = "" in
    (transfer (memref (sub Op3:GPR Op4:GPR)) Op2:GPR);
) cost 1;

//====-- LDR --====//
define instruction ldr1 semantic as (
  let Op1 = "" in
    (transfer Op2:GPR (memref Op3:GPR));
) cost 1;
define instruction ldr1 semantic as () cost 1;
define instruction ldr1 semantic as () cost 1;
define instruction ldr1 semantic as (
  let Op1 = "" in
    (transfer Op2:GPR (memref (add Op3:GPR imm:Op4:tgtimm)));
) cost 1;

define instruction ldr2 semantic as (
  let Op1 = "" in
    (transfer Op2:GPR (memref (add Op3:GPR Op4:GPR)));
) cost 1;
define instruction ldr2 semantic as (
  let Op1 = "" in
    (transfer Op2:GPR (memref (sub Op3:GPR Op4:GPR)));
) cost 1;
define instruction ldr2 semantic as () cost 1;
define instruction ldr2 semantic as (
  let Op1 = "", Op5 = "LSL" in
    (transfer Op2:GPR (memref (add Op3:GPR RegShiftedAddrMode:fragment params (Op4 Op6))));
  let Op1 = "", Op5 = "LSR" in
    (transfer Op2:GPR (memref (add Op3:GPR RegRightShiftedAddrMode:fragment params (Op4 Op6))));
  let Op1 = "", Op5 = "ASR" in
    (transfer Op2:GPR (memref (add Op3:GPR RegARightShiftedAddrMode:fragment params (Op4 Op6))));
) cost 1;
define instruction ldr2 semantic as (
  let Op1 = "", Op5 = "LSL" in
    (transfer Op2:GPR (memref (sub Op3:GPR RegShiftedAddrMode:fragment params (Op4 Op6))));
  let Op1 = "", Op5 = "LSR" in
    (transfer Op2:GPR (memref (sub Op3:GPR RegRightShiftedAddrMode:fragment params (Op4 Op6))));
  let Op1 = "", Op5 = "ASR" in
    (transfer Op2:GPR (memref (sub Op3:GPR RegARightShiftedAddrMode:fragment params (Op4 Op6))));
) cost 1;

//translate (transfer a3:regs (+ a1:immed a2:immed));

//translate (transfer a3:int (+ a1:int a2:int));
