//===- rules.txt   Transformation rules definition file   -----------------===//
//
//              The ArchC Project - Compiler Backend Generation
//
//===----------------------------------------------------------------------===//
//
// BLABLA
//
//===----------------------------------------------------------------------===//

//==========================-- Operators --===================================//

// Built-in operators: +, -, ~, transfer, call, ret
// These operands must exist
define operator +        as arity 2;
define operator -        as arity 2;
define operator ~        as arity 1;
define operator xor      as arity 2;
define operator transfer as arity 2;
define operator if       as arity 3;
define operator equal    as arity 2;
define operator dec      as arity 2;
define operator shl      as arity 2;            // Shift left
define operator shr      as arity 2;            // Shift right
define operator and      as arity 2;
define operator or       as arity 2;
define operator memref   as arity 1;
define operator call     as arity 1;
define operator jump     as arity 1;
// CJUMP is a special conditional jump node and is not straightforward
// The first operand has the conditional code, the second is the
// comparator operator and the third, the target
define operator cjump    as arity 3;
define operator comp     as arity 2;
define operator alias    as add => +;
define operator alias    as sub => -;


//===========================-- Operands --===================================//

// Built-in operands: int
// These operands must exist
define operand int    as size 32;
define operand mem    as size 32;
define operand cond   as size 32;
define operand regs   as size 32 like int;
define operand immed  as size 32 like int;
define operand short  as size 16 like int;
define operand byte   as size 8  like int;
define operand nibble as size 4  like int;
define operand bit    as size 1  like int;

//============================-- Rules --=====================================//

AnyOperator:any => (dec (transfer AReg:regs AnyOperator:any) AReg:regs);

AnyOperator:any <=> (+ const:int:0 AnyOperator:any);

const:int:0 => (xor Reg:regs Reg:regs);

(transfer OperA:any OperB:any) => 
	  (dec (transfer AReg:regs const:int:1)
	  {AReg:regs == const:int:1} -> (transfer OperA:any OperB:any))
	  ;

(transfer OperA:any OperB:any) =>
	  {AReg:regs == AReg:regs} -> (transfer OperA:any OperB:any);
	  

//{LHS:regs < RHS:regs} -> AnyOperator:any => 
//	  (dec {LHS:reg < RHS:regs} -> (transfer OperA:any OperB:any)
//	  {OperA:any == OperB:any} -> AnyOperator:any)
// {AReg:regs == const:int:1} ->
// (transfer OperA:any OperB:any) <=> (dec (transfer AReg:regs const:int:1) 
// (transfer OperA:any OperB:any));

//=========================-- LLVM Patterns --================================//

// It is important to order similar patterns, most restrictive first.

define pattern STOREFICONST as (
  "(store (imm i32:$src), (frameindex i32:$val))";
  (transfer (memref (+ val:regs imm:val:immed)) imm:src:immed);
);

// Built-in pattern: STOREFI is used to determine how the backend will spill
// registers to stack frame. This pattern must exist, with the correct
// operand names (src and val).
define pattern STOREFI as (
  "(store i32:$src, (frameindex i32:$val))";
  (transfer (memref (+ val:regs imm:val:immed)) src:regs);
);

define pattern STORE as (
  "(store i32:$src, i32:$addr)";
  (transfer (memref addr:regs) src:regs);
);

// Built-in pattern: LOADFI is used to determine how the backend will load
// spilled registers from stack frame. This pattern must exist, with the
// correct operand names (addr and dest).
define pattern LOADFI as (
  "(load (frameindex i32:$addr))";
  (transfer dest:regs (memref (+ addr:regs imm:addr:immed)));
);

define pattern LOAD as (
  "(load i32:$addr)";
  (transfer a3:regs (memref addr:regs));
);

define pattern GLOBALADDRESS as (
  "(globaladdr i32:$addr)";
  (transfer a3:regs (memref (+ addr:regs imm:addr:immed)));
);

//define pattern FRAMEINDEX as (
//  "(frameindex)";
//  (transfer a3:regs imm:val:immed);
//);

define pattern CALL as (
  "(call (tglobaladdr i32:$tgt))";
  (call imm:tgt:immed);
);

define pattern ADDCONST as (
  "(add i32:$a1, (imm i32:$a2))";
  (transfer a3:regs (+ a1:regs imm:a2:immed));
);

define pattern ADD as (
  "(add i32:$a1, i32:$a2)";
  (transfer a3:regs (+ a1:regs a2:regs));
);

define pattern BRCOND as (
  "(br_cc (condcode SETLT) i32:$lhs i32:$rhs (basicblock i32:$tgt))";
  (cjump const:cond:lt (comp lhs:regs rhs:regs) imm:tgt:immed);
);

define pattern CONST as (
  "(imm i32:$a1)";
  (transfer a2:regs imm:a1:immed);
);

// { lhs < rhs }  SR == LT
// { SR == LT } brancheio 


//====================-- Machine specific rules --============================//

//=====================-- Registers definitions --============================//

// Current Program Status Register

define registers CPSR:regs as ( SR );  // Status register

define registers GPR:regs as (
  r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10 r11 r12 r13 r14 r15
);

//===========================-- ABI stuff --==================================//

define abi as (
  define callee save registers as (r4 r5 r6 r7);
  define reserved registers as    (r9 r13 r14 r15);
  define auxiliar registers as    (r9);
  //define calling convention for int as stack size 4 alignment 4;
  define calling convention for int as (r0 r1 r2 r3);
  define return convention for int as (r0 r1);
  define programcounter register as r15;
  define stackpointer register as r13;
  define framepointer register as r11;
  define return register as r14;
  define stack grows down alignment 8;
  define pcoffset -8;
);

//==================-- Instruction semantic fragments --======================//

//====-- Adressing mode fragments -====//

// Simple addressing mode frag
define semantic fragment SimpleAddrMode as (
  Op5:GPR;    
);

// Register shifted by imm 
define semantic fragment RegShiftedAddrMode as (
  (shl Op5:GPR Op7:immed);
);

// Register shifted right by 1 
define semantic fragment RegRotAddrMode as (
  (shr Op5:GPR const:int:1);
);

// Register shifted by an value defined in a register
define semantic fragment RegShifted2AddrMode as (
  (shl Op5:GPR Op7:GPR);
);

// Immediate
define semantic fragment ImmAddrMode as (
  imm:Op5:immed;
);

//=======================-- Instructions definitions --=======================//

// Branch instructions
define instruction b semantic as (
  let Op1 = "" in
    (jump imm:Op2:immed);
  let Op1 = "lt" in
    (cjump const:cond:lt SR:CPSR imm:Op2:immed);
) cost 1;
define instruction b semantic as (
  let Op1 = "" in
    (call imm:Op2:immed);
) cost 1;

// Data processing instructions

//====-- AND --====//
define instruction and1 semantic as (
  (transfer Op3:GPR (and Op4:GPR SimpleAddrMode:fragment));
) cost 1;
define instruction and1 semantic as (
  (transfer Op3:GPR (and Op4:GPR RegShiftedAddrMode:fragment));
) cost 1;
define instruction and1 semantic as (
  (transfer Op3:GPR (and Op4:GPR RegRotAddrMode:fragment));
) cost 1;
define instruction and2 semantic as (
  (transfer Op3:GPR (and Op4:GPR RegShifted2AddrMode:fragment));
) cost 1;
define instruction and3 semantic as (
  (transfer Op3:GPR (and Op4:GPR ImmAddrMode:fragment));
) cost 1;

//====-- EOR --====//
define instruction eor1 semantic as (
  let Op1 = "", Op2 = "" in
    (transfer Op3:GPR (xor Op4:GPR SimpleAddrMode:fragment));
) cost 1;
define instruction eor1 semantic as (
  (transfer Op3:GPR (xor Op4:GPR RegShiftedAddrMode:fragment));
) cost 1;
define instruction eor1 semantic as (
  (transfer Op3:GPR (xor Op4:GPR RegRotAddrMode:fragment));
) cost 1;
define instruction eor2 semantic as (
  (transfer Op3:GPR (xor Op4:GPR RegShifted2AddrMode:fragment));
) cost 1;
define instruction eor3 semantic as (
  (transfer Op3:GPR (xor Op4:GPR ImmAddrMode:fragment));
) cost 1;

//====-- SUB --====//
define instruction sub1 semantic as (
let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (- Op4:GPR SimpleAddrMode:fragment));
) cost 1;
define instruction sub1 semantic as (
let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (- Op4:GPR RegShiftedAddrMode:fragment));
) cost 1;
define instruction sub1 semantic as (
let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (- Op4:GPR RegRotAddrMode:fragment));
) cost 1;
define instruction sub2 semantic as (
let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (- Op4:GPR RegShifted2AddrMode:fragment));
) cost 1;
define instruction sub3 semantic as (
let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (- Op4:GPR ImmAddrMode:fragment));
) cost 1;

//====-- ADD --====//
define instruction add1 semantic as (
  let Op1 = "", Op2 = "" in
    (transfer Op3:GPR (+ Op4:GPR SimpleAddrMode:fragment));
) cost 1;
define instruction add1 semantic as (
  let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (+ Op4:GPR RegShiftedAddrMode:fragment));
) cost 1;
define instruction add1 semantic as (
  let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (+ Op4:GPR RegRotAddrMode:fragment));
) cost 1;
define instruction add2 semantic as (
  let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (+ Op4:GPR RegShifted2AddrMode:fragment));
) cost 1;
define instruction add3 semantic as (
  let Op1 = "", Op2 = "" in
  (transfer Op3:GPR (+ Op4:GPR ImmAddrMode:fragment));
) cost 1;

//====-- ORR --====//
define instruction orr1 semantic as (
  (transfer Op3:GPR (or Op4:GPR SimpleAddrMode:fragment));
) cost 1;
define instruction orr1 semantic as (
  (transfer Op3:GPR (or Op4:GPR RegShiftedAddrMode:fragment));
) cost 1;
define instruction orr1 semantic as (
  (transfer Op3:GPR (or Op4:GPR RegRotAddrMode:fragment));
) cost 1;
define instruction orr2 semantic as (
  (transfer Op3:GPR (or Op4:GPR RegShifted2AddrMode:fragment));
) cost 1;
define instruction orr3 semantic as (
  (transfer Op3:GPR (or Op4:GPR ImmAddrMode:fragment));
) cost 1;

//====-- CMP --====//
define instruction cmp1 semantic as (
let Op1 = "" in
  (transfer SR:CPSR (comp Op2:GPR SimpleAddrMode:fragment params (Op3)));
) cost 1;
define instruction cmp1 semantic as (
let Op1 = "" in
  (transfer SR:CPSR (comp Op2:GPR RegShiftedAddrMode:fragment params (Op3 Op4)));
) cost 1;
define instruction cmp1 semantic as (
let Op1 = "" in
  (transfer SR:CPSR (comp Op2:GPR RegRotAddrMode:fragment params (Op3)));
) cost 1;
define instruction cmp2 semantic as (
let Op1 = "" in
  (transfer SR:CPSR (comp Op2:GPR RegShifted2AddrMode:fragment params (Op3 Op4)));
) cost 1;
define instruction cmp3 semantic as (
let Op1 = "" in
  (transfer SR:CPSR (comp Op2:GPR ImmAddrMode:fragment params (Op3)));
) cost 1;

//====-- MOV --====//
define instruction mov1 semantic as (
  let Op1 = "", Op2 = "" in
    (transfer Op3:GPR SimpleAddrMode:fragment params (Op4));
) cost 1;
define instruction mov1 semantic as (
  (transfer Op3:GPR RegShiftedAddrMode:fragment params (Op4 Op6));
) cost 1;
define instruction mov1 semantic as (
  (transfer Op3:GPR RegRotAddrMode:fragment params (Op4));
) cost 1;
define instruction mov2 semantic as (
  (transfer Op3:GPR RegShifted2AddrMode:fragment params (Op4 Op6));
//  (transfer Op3:GPR const:int:1);
) cost 1;
define instruction mov3 semantic as (
 let Op1 = "", Op2 = "" in
 //   {SR:CPSR == const:int:1} ->  	
  (transfer Op3:GPR ImmAddrMode:fragment params (Op4));
) cost 1;

//====-- TEQ --====//
//define instruction teq1 semantic as (
  //let Op1 = "" in
    //{Op2:GPR == Op3:GPR} -> (transfer SR:CPSR const:int:1);
  //let Op1 = "" in
//    {Op2:GPR < Op3:GPR} -> (transfer SR:CPSR const:int:10);  
//) cost 1;

//====-- STR --====//
define instruction str1 semantic as (
  let Op1 = "" in
    (transfer (memref Op3:GPR) Op2:GPR);
) cost 1;

//====-- LDR --====//
define instruction ldr1 semantic as (
  let Op1 = "" in
    (transfer Op2:GPR (memref Op3:GPR));
) cost 1;


//translate (transfer a3:regs (+ a1:immed a2:immed));

//translate (transfer a3:int (+ a1:int a2:int));
