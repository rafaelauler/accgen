//===- rules.txt   Transformation rules definition file   -----------------===//
//
//              The ArchC Project - Compiler Backend Generation
//
//===----------------------------------------------------------------------===//
//
// BLABLA
//
//===----------------------------------------------------------------------===//

//==========================-- Operators --===================================//

define operator +        as arity 2;
define operator -        as arity 2;
define operator xor      as arity 2;
define operator transfer as arity 2;
define operator if       as arity 3;
define operator equal    as arity 2;
define operator dec      as arity 2;
define operator alias    as add => +;
define operator alias    as sub => -;


//===========================-- Operands --===================================//

define operand int   as size 32;
define operand regs  as size 32 like int;
define operand immed as size 32 like int;
define operand short as size 16 like int;
define operand byte  as size 8  like int;
define operand bit   as size 1  like int;

//============================-- Rules --=====================================//

AnyOperator:any => (dec (transfer AReg:regs AnyOperator:any) AReg:regs);

AnyOperator:any <=> (+ const:int:0 AnyOperator:any);

const:int:0 <=> (xor Reg:regs Reg:regs);

// Machine description

//=====================-- Registers definitions --============================//

define registers GPR:regs as (
  r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10 r11 r12 r13 r14 r15
  r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 r26 r27 r28 r29 r30 r31
);

// Current Program Status Register

define registers CPSRbitN:bit as ( N );  // bit Negative
define registers CPSRbitV:bit as ( V );  // bit Overflow
define registers CPSRbitZ:bit as ( Z );  // bit Zero
define registers CPSRbitC:bit as ( C );  // bit Carry

//===========================-- ABI stuff --==================================//

define abi as (
  define callee save registers as (r5   r6   r7);
  define reserved registers as    (r29  r30  r31);
  define calling convention for int as stack size 4 alignment 4;
  define return convention for int as (r8 r9 r10);
);

//==================-- Instruction semantic fragments --======================//

// Addressing mode frag
define semantic fragment AddrMode as (
  Op5:GPR;    // Simple register addressing
  (+ Op5:GPR Op6:GPR); //test
);

//=======================-- Instructions definitions --=======================//

// Add instruction with two registers operands
define instruction add1 semantic as (
//  (transfer Op3:GPR (+ Op4:GPR Op5:GPR));
  (transfer Op3:GPR (+ Op4:GPR AddrMode:fragment));
) cost 1;

//Add instruction with immediate operand
define instruction add3 semantic as (
  (transfer Op3:GPR (+ Op4:GPR Op5:immed));
) cost 1;

define instruction eor1 semantic as (
  (transfer Op3:GPR (xor Op4:GPR Op5:GPR));
) cost 1;

translate (transfer a3:regs (+ a1:immed a2:immed));

//translate (transfer a3:int (+ a1:int a2:int));
